<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Devops 60 hrs</title>
    <link>https://github.com/khushiramsingh680/devops-60hrs/index.html</link>
    <description>DevOps bridges the gap between development and operations, fostering a culture of collaboration and continuous improvement. With automation at its core, DevOps accelerates software delivery while ensuring stability, scalability, and security. Adopting DevOps practices empowers teams to innovate faster, respond to change efficiently, and deliver greater value to customers. 📚 Table of Contents 🟢 Getting Started VirtualBox, Vagrant, and Basics of Linux 📘 Linux Administration 🔹 Introduction to Linux History and Evolution Linux Distributions Overview System Architecture Basics 🔹 User and Group Management Creating and Managing Users Group Administration Switching Users and sudo Access 🔹 File System and Directory Structure Linux Directory Hierarchy Explained Mounting and Unmounting File Systems Disk Partitioning and LVM Basics 🔹 File and Directory Permissions Understanding rwx Permissions chmod, chown, and chgrp Access Control Lists (ACLs) Special Permissions: SUID, SGID, Sticky Bit 🔹 Package Management apt, yum, dnf, zypper Installing, Updating, and Removing Software Managing Repositories Compiling from Source 🔹 Process and Service Management Understanding System Processes Commands: ps, top, htop, kill, nice Managing Services with systemctl Startup and Boot Targets 🔹 Performance Monitoring and Tuning CPU, Memory, Disk, Network Monitoring Identifying Bottlenecks Log Analysis and Rotation 🔹 Networking Essentials Network Configuration: Static &amp; DHCP Tools: ip, netstat, ss, ping, traceroute, nmap Firewalls: iptables, firewalld, ufw SSH Configuration and Security 🔹 Storage Management Mounting Disks and File Systems Logical Volume Management (LVM) Filesystem Types: ext4, xfs, btrfs, etc. 🔹 Backup and Recovery Tools: rsync, tar, dd Scheduled Backups using cron Snapshot and Restore Disaster Recovery Strategy 🔹 Security and Hardening User Privileges and Auditing SSH Key Authentication SELinux/AppArmor Basics Patch Management and Vulnerability Scanning 🔹 Automation and Scripting Shell Scripting Basics Scheduling Tasks with cron Automation of Admin Tasks 🔹 Logging and Troubleshooting Using journalctl and log files Boot, Network, and Service Troubleshooting Rescue Mode and Recovery 🔹 Virtualization and Containers KVM and VirtualBox Basics Introduction to Docker and Podman Linux Namespaces and Cgroups 🔐 SSL/TLS with OpenSSL 🔹 SSL/TLS Fundamentals What is SSL/TLS Key Concepts: PKI, Certificates, CSRs TLS Handshake Overview 🔹 Certificate Generation Creating Private Keys Generating CSRs Adding SANs with openssl.cnf Creating Self-Signed Certs 🔹 Key and Cert Management Formats: PEM, DER, CRT, CER, KEY Extract Public Keys Convert Between Formats 🔹 Certificate Validation Match Cert and Key View Certificate and CSR Details Check Validity Periods 🔹 Advanced CSR Fields Using Config Files Key Usage and Extended Usage SAN and Custom Extensions 🔹 Certificate Deployment For Nginx, Apache, HAProxy Intermediate Chains Secure File Permissions 🔹 Testing SSL openssl s_client Cipher Suite Validation SSL Labs Testing 🔹 Renewal and Automation Manual vs Automated Renewal certbot, acme.sh Usage Renewal Hooks 🔹 Troubleshooting and Best Practices Common Errors (Mismatches, Expired Certs) Storage Best Practices TLS Hardening 🔹 Local Development Using Local CAs Tools: mkcert Browser Trust Configurations ⚙️ Ansible for RHEL 8/9 🔹 Introduction to Ansible Overview and Architecture Agentless Automation Benefits 🔹 Setup and Configuration Installing via DNF Configuring ansible.cfg Setting up Inventory 🔹 Inventory Management Static and Dynamic Inventories SSH Key Authentication Grouping Hosts 🔹 Package Management Modules: dnf, yum, rpm Enabling EPEL and Custom Repos Managing RPMs 🔹 Service Management service and systemd Modules Enabling/Disabling Services Restarting and Reloading 🔹 User and Group Tasks Create/Remove Users Managing SSH Keys ACL and Permissions 🌱 OpenTofu (Terraform Fork) Intro to OpenTofu Open-source Terraform alternative Community-driven governance Why Switch Licensing, transparency, neutrality Installation OpenTofu CLI Migration from Terraform Code Compatibility Using existing Terraform HCL Providers Open registry support State Management Compatible backends State locking and drift detection Modules Reusable and shareable configs CLI Commands tofu plan, tofu apply, etc. CI/CD Integration in pipelines GitLab, GitHub Actions Best Practices Naming, modularity, Git workflows</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://github.com/khushiramsingh680/devops-60hrs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vagrant: Day 01</title>
      <link>https://github.com/khushiramsingh680/devops-60hrs/part01/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/khushiramsingh680/devops-60hrs/part01/index.html</guid>
      <description>📦 Vagrant - Day 01 1. Introduction to Vagrant What is Vagrant? Vagrant is an open-source tool that allows you to build and manage virtualized development environments.&#xA;Benefits of Using Vagrant&#xA;Reproducibility Isolation Simplified provisioning Use Cases&#xA;DevOps automation Testing infrastructure Multi-VM environments 2. Installation Linux/Mac/Windows Step 1: Install VirtualBox&#xA;https://www.virtualbox.org/wiki/Downloads&#xA;Step 2: Install Vagrant&#xA;https://www.vagrantup.com/downloads&#xA;Verify Installation:&#xA;vagrant --version 3. Vagrantfile Basics Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/bionic64&#34; config.vm.network &#34;private_network&#34;, type: &#34;dhcp&#34; config.vm.synced_folder &#34;./data&#34;, &#34;/vagrant_data&#34; config.vm.provider &#34;virtualbox&#34; do |vb| vb.memory = &#34;1024&#34; vb.cpus = 2 end end Key Options: config.vm.box: Defines the base box Networking: private, public, and port forwarding Synced folders: sharing between host and guest 4. Provisioning Methods:</description>
    </item>
    <item>
      <title>Linux Basics: Day 02</title>
      <link>https://github.com/khushiramsingh680/devops-60hrs/part02/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/khushiramsingh680/devops-60hrs/part02/index.html</guid>
      <description>1. pwd (Print Working Directory) Usage: pwd&#xA;Explanation: This command prints the full path of the current working directory. It helps users confirm where they are in the directory structure.&#xA;Example:&#xA;$ pwd /home/user 2. ls (List) Usage: ls&#xA;Explanation: Lists the files and directories within the current directory. By default, ls will not show hidden files (files starting with a dot). Use options like -l for detailed listing or -a for all files.</description>
    </item>
    <item>
      <title>User, Group and Permissions: Day 03</title>
      <link>https://github.com/khushiramsingh680/devops-60hrs/part03/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/khushiramsingh680/devops-60hrs/part03/index.html</guid>
      <description>User Management in Rocky Linux 9 Overview User management in Linux involves creating, modifying, and deleting user accounts, as well as assigning user privileges and managing groups. In Rocky Linux 9, user management is done via command-line tools like useradd, usermod, userdel, and groupadd.&#xA;1. useradd (Create a New User) Usage: useradd &lt;username&gt;&#xA;Explanation: The useradd command is used to create a new user account. The command creates the user’s home directory and sets up default user configuration files.</description>
    </item>
    <item>
      <title>Linux Disk Management: Day 04</title>
      <link>https://github.com/khushiramsingh680/devops-60hrs/part04/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/khushiramsingh680/devops-60hrs/part04/index.html</guid>
      <description>📂 1. Listing Disks and Partitions View all block devices: lsblk Show detailed partition table: fdisk -l View disk usage: df -h View inode usage: df -i 🧱 2. Partitioning Disks Using fdisk (for MBR-style partitions): sudo fdisk /dev/sdX # n -&gt; new partition # p -&gt; primary # w -&gt; write changes Using parted (for GPT and scripting): sudo parted /dev/sdX (parted) mklabel gpt (parted) mkpart primary ext4 1MiB 100% (parted) quit 🛠️ 3. Creating Filesystems Create ext4 filesystem: sudo mkfs.ext4 /dev/sdX1 Create xfs filesystem: sudo mkfs.xfs /dev/sdX1 📦 4. Mounting and Unmounting Disks Create a mount point and mount: sudo mkdir /mnt/data sudo mount /dev/sdX1 /mnt/data Unmount: sudo umount /mnt/data View mounted filesystems: mount | grep sd 🔁 5. Persistent Mounting with /etc/fstab Get UUID: blkid /dev/sdX1 Edit /etc/fstab: UUID=xxxx-xxxx /mnt/data ext4 defaults 0 2 Then run:</description>
    </item>
    <item>
      <title>Linux Package Management: Day 05</title>
      <link>https://github.com/khushiramsingh680/devops-60hrs/part05/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://github.com/khushiramsingh680/devops-60hrs/part05/index.html</guid>
      <description>📦 What is Package Management? Linux uses package managers to install, update, and remove software efficiently while resolving dependencies.&#xA;🧰 1. Debian/Ubuntu: apt (Advanced Package Tool) Update package list: sudo apt update Upgrade packages: sudo apt upgrade Install a package: sudo apt install package-name Remove a package: sudo apt remove package-name Remove unused packages: sudo apt autoremove Search for a package: apt search nginx 🍱 2. RHEL/CentOS/Rocky: yum and dnf On RHEL 8+ and Fedora, use dnf instead of yum.</description>
    </item>
  </channel>
</rss>